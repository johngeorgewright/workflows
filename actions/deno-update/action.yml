name: Deno Update

author: johngeorgewright

description: Like dependabot, but only for Deno - automatically creates PRs for outdated dependencies

inputs:
  github-token:
    description: GitHub token with permissions to create PRs
    required: true
  version-policy:
    description: Version update policy - "compatible" (respect semver), "latest" (all updates), or "patch" (patch only)
    required: false
    default: latest
  working-directory:
    description: Optional directory to execute in
    required: false
    default: .
  pr-labels:
    description: Comma-separated labels to apply to PRs
    required: false
    default: dependencies,deno
  dry-run:
    description: If true, only check for updates without creating PRs
    required: false
    default: 'false'
  recursive:
    description: If true, checks workspace members recursively (--recursive flag)
    required: false
    default: 'false'
  preserve-semver-prefix:
    description: If true, preserves semver prefixes (^, ~) when updating versions
    required: false
    default: 'true'

runs:
  using: composite
  steps:
    - name: Configure git
      shell: bash
      run: | # shell
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Check for outdated dependencies and create PRs
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        VERSION_POLICY: ${{ inputs.version-policy }}
        PR_LABELS: ${{ inputs.pr-labels }}
        DRY_RUN: ${{ inputs.dry-run }}
        RECURSIVE: ${{ inputs.recursive }}
        PRESERVE_SEMVER_PREFIX: ${{ inputs.preserve-semver-prefix }}
      run: | # shell
        set -e
        
        echo "ðŸ” Checking for outdated Deno dependencies..."
        echo ""
        
        # Verify deno.json exists
        if [[ ! -f "deno.json" ]] && [[ ! -f "deno.jsonc" ]]; then
          echo "âŒ Error: No deno.json or deno.jsonc file found in the current directory"
          echo "Current directory: $(pwd)"
          echo "Files in directory:"
          ls -la
          exit 1
        fi
        
        # Initialize step summary
        echo "# Deno Dependency Updates" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Build deno command flags
        DENO_FLAGS=""
        if [[ "$RECURSIVE" == "true" ]]; then
          DENO_FLAGS="--recursive"
        fi
        
        # Run deno outdated and capture output
        if ! OUTDATED_OUTPUT=$(deno outdated $DENO_FLAGS 2>&1); then
          echo "âŒ Error running deno outdated:"
          echo "$OUTDATED_OUTPUT"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âŒ **Error:** Failed to run \`deno outdated\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$OUTDATED_OUTPUT" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        # Check if output is empty (might indicate no deno.lock or other issue)
        if [[ -z "$OUTDATED_OUTPUT" ]]; then
          echo "âš ï¸ Warning: deno outdated produced no output"
          echo "This usually means:"
          echo "  - No deno.lock file exists (run 'deno install' first)"
          echo "  - Or all dependencies are up to date"
          echo ""
          echo "Checking for deno.lock..."
          if [[ ! -f "deno.lock" ]]; then
            echo "âŒ Error: No deno.lock file found"
            echo "Please run 'deno install' in your repository first to generate deno.lock"
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **Error:** No \`deno.lock\` file found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The Deno Update action requires a \`deno.lock\` file to track dependencies." >> $GITHUB_STEP_SUMMARY
            echo "Please run \`deno install\` in your repository and commit the generated \`deno.lock\` file." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          echo "âœ“ deno.lock exists, assuming all dependencies are up to date"
          echo "âœ“ All dependencies are up to date!" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        echo "$OUTDATED_OUTPUT"
        echo ""
        
        # Create temp file for summary (because pipe creates subshell)
        SUMMARY_FILE=$(mktemp)
        FAILED_UPDATES=0
        
        # Parse the table output and process each outdated dependency
        # Skip header and border lines, extract package, current, and latest versions
        echo "$OUTDATED_OUTPUT" | tail -n +4 | grep -v "^[â””â”œâ”Œ]" | while IFS= read -r line; do
          # Extract fields from table row: â”‚ Package â”‚ Current â”‚ Update â”‚ Latest â”‚
          if [[ $line =~ â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚ ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            CURRENT="${BASH_REMATCH[2]}"
            LATEST="${BASH_REMATCH[4]}"
            
            # Trim whitespace
            PACKAGE=$(echo "$PACKAGE" | xargs)
            CURRENT=$(echo "$CURRENT" | xargs)
            LATEST=$(echo "$LATEST" | xargs)
            
            # Skip if empty
            [[ -z "$PACKAGE" ]] && continue
            
            # Determine update type (major/minor/patch)
            CURRENT_PARTS=(${CURRENT//./ })
            LATEST_PARTS=(${LATEST//./ })
            
            UPDATE_TYPE="patch"
            if [[ ${LATEST_PARTS[0]} -gt ${CURRENT_PARTS[0]} ]]; then
              UPDATE_TYPE="major"
            elif [[ ${LATEST_PARTS[1]} -gt ${CURRENT_PARTS[1]} ]]; then
              UPDATE_TYPE="minor"
            fi
            
            # Apply version policy filter
            case "$VERSION_POLICY" in
              patch)
                [[ "$UPDATE_TYPE" != "patch" ]] && continue
                ;;
              compatible)
                [[ "$UPDATE_TYPE" == "major" ]] && continue
                ;;
              latest)
                # Update everything
                ;;
            esac
            
            echo "Processing: $PACKAGE ($CURRENT â†’ $LATEST) [$UPDATE_TYPE]"
            
            # Sanitize package name for branch
            SAFE_NAME=$(echo "$PACKAGE" | sed 's|^jsr:||; s|^npm:||; s|^https\?://||; s|[@/]|-|g; s|[^a-zA-Z0-9._-]||g')
            BRANCH_NAME="dependencies/deno/$SAFE_NAME"
            
            # Check if PR already exists
            EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
            
            # Get default branch
            DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d: -f2 | xargs)
            
            # Create or update branch
            git fetch origin "$DEFAULT_BRANCH"
            if git rev-parse --verify "origin/$BRANCH_NAME" >/dev/null 2>&1; then
              echo "  Updating existing branch: $BRANCH_NAME"
              git checkout -B "$BRANCH_NAME" "origin/$DEFAULT_BRANCH"
            else
              echo "  Creating new branch: $BRANCH_NAME"
              git checkout -b "$BRANCH_NAME" "origin/$DEFAULT_BRANCH"
            fi
            
            # Update dependency using deno update
            # Strip protocol-style prefix (jsr:, npm:, http://, https://, etc.) from package name
            UPDATE_PACKAGE="${PACKAGE#*://}"  # Strip protocol:// if present
            [[ "$UPDATE_PACKAGE" == "$PACKAGE" ]] && UPDATE_PACKAGE="${PACKAGE#*:}"  # Otherwise strip prefix:
            
            # Detect semver prefix from deno.json before update
            SEMVER_PREFIX=""
            if [[ "$PRESERVE_SEMVER_PREFIX" == "true" ]]; then
              # Extract the version constraint from deno.json for this package
              if [[ -f "deno.json" ]]; then
                CURRENT_VERSION=$(jq -r ".imports[\"$PACKAGE\"]? // empty" deno.json 2>/dev/null || echo "")
                if [[ "$CURRENT_VERSION" =~ @(\^|~) ]]; then
                  SEMVER_PREFIX="${BASH_REMATCH[1]}"
                  echo "  Detected semver prefix '$SEMVER_PREFIX'"
                fi
              fi
            fi
            
            # Use deno add instead of deno update to force the specific version
            # This bypasses any semver constraints in deno.json
            if ! deno add "$PACKAGE@$LATEST"; then
              echo "  âš  Could not update $PACKAGE - skipping"
              FAILED_UPDATES=$((FAILED_UPDATES + 1))
              git checkout "$DEFAULT_BRANCH"
              continue
            fi
            
            # Restore semver prefix if it was present (deno add removes it)
            if [[ -n "$SEMVER_PREFIX" ]] && [[ -f "deno.json" ]]; then
              # Replace the version in deno.json to include the semver prefix
              TEMP_FILE=$(mktemp)
              jq ".imports[\"$PACKAGE\"] = (.imports[\"$PACKAGE\"] | sub(\"@([0-9])\"; \"@${SEMVER_PREFIX}\\1\"))" deno.json > "$TEMP_FILE" && mv "$TEMP_FILE" deno.json
              echo "  âœ“ Restored semver prefix '$SEMVER_PREFIX'"
            fi
            
            # Check if anything changed
            if git diff --quiet; then
              echo "  No changes needed"
              git checkout "$DEFAULT_BRANCH"
              continue
            fi
            
            echo "  âœ“ Updated $PACKAGE"
            
            # Commit and push
            COMMIT_MSG="Bump $PACKAGE from $CURRENT to $LATEST"
            git add .
            git commit -m "$COMMIT_MSG"
            git push -f origin "$BRANCH_NAME"
            
            # Create or update PR
            PR_BODY="Bumps \`$PACKAGE\` from $CURRENT to $LATEST.
            
            **Update type:** $UPDATE_TYPE
            
            ---
            Created by [Deno Update Action](https://github.com/johngeorgewright/workflows)"
            
            if [[ -n "$EXISTING_PR" ]]; then
              echo "  âœ“ Updated PR #$EXISTING_PR"
              gh pr edit "$EXISTING_PR" --title "$COMMIT_MSG" --body "$PR_BODY"
              echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${LATEST}\` (_${UPDATE_TYPE}_) - Updated PR [#${EXISTING_PR}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/pull/${EXISTING_PR})" >> "$SUMMARY_FILE"
            else
              # Build label arguments and ensure labels exist
              LABELS_ARG=""
              if [[ -n "$PR_LABELS" ]]; then
                IFS=',' read -ra LABELS <<< "$PR_LABELS"
                for LABEL in "${LABELS[@]}"; do
                  LABEL=$(echo "$LABEL" | xargs)
                  # Create label if it doesn't exist
                  if ! gh label list --json name --jq '.[].name' | grep -q "^${LABEL}$"; then
                    echo "  Creating label: $LABEL"
                    if gh label create "$LABEL" --color "0366d6" --description "Automated label" 2>/dev/null; then
                      echo "  âœ“ Created label '$LABEL'" >> "$SUMMARY_FILE"
                    fi
                  fi
                  LABELS_ARG="$LABELS_ARG --label $LABEL"
                done
              fi
              
              # Add --dry-run flag if in dry-run mode
              DRY_RUN_FLAG=""
              if [[ "$DRY_RUN" == "true" ]]; then
                DRY_RUN_FLAG="--dry-run"
              fi
              
              PR_URL=$(gh pr create \
                --title "$COMMIT_MSG" \
                --body "$PR_BODY" \
                --base "$DEFAULT_BRANCH" \
                --head "$BRANCH_NAME" \
                $LABELS_ARG \
                $DRY_RUN_FLAG)
              PR_NUMBER=$(echo "$PR_URL" | sed -n 's|.*/pull/\([0-9]*\)|\1|p')
              
              if [[ "$DRY_RUN" == "true" ]]; then
                echo "  âœ“ Would create PR (dry-run)"
                echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${LATEST}\` (_${UPDATE_TYPE}_) - Would create PR (dry-run)" >> "$SUMMARY_FILE"
              else
                echo "  âœ“ Created PR #$PR_NUMBER"
                echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${LATEST}\` (_${UPDATE_TYPE}_) - Created PR [#${PR_NUMBER}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/pull/${PR_NUMBER})" >> "$SUMMARY_FILE"
              fi
            fi
            
            # Return to default branch for next iteration
            git checkout "$DEFAULT_BRANCH"
            echo ""
          fi
        done
        
        # Write summary to step summary
        if [[ -s "$SUMMARY_FILE" ]]; then
          echo "## Updates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat "$SUMMARY_FILE" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "_Running in dry-run mode - no PRs were created_" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "âœ“ All dependencies are up to date!" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Clean up temp file
        rm -f "$SUMMARY_FILE"
        
        if [[ $FAILED_UPDATES -gt 0 ]]; then
          echo ""
          echo "âŒ Failed to update $FAILED_UPDATES package(s)"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Warning:** $FAILED_UPDATES package(s) could not be updated. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        echo "âœ“ Done!"