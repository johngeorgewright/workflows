name: Deno Update

author: johngeorgewright

description: Like dependabot, but only for Deno - automatically creates PRs for outdated dependencies

inputs:
  github-token:
    description: GitHub token with permissions to create PRs
    required: true
  version-policy:
    description: Version update policy - "compatible" (semver compatible updates) or "latest" (all updates)
    required: false
    default: latest
  working-directory:
    description: Optional directory to execute in
    required: false
    default: .
  pr-labels:
    description: Comma-separated labels to apply to PRs
    required: false
    default: dependencies,deno
  dry-run:
    description: If true, only check for updates without creating PRs
    required: false
    default: 'false'
  recursive:
    description: If true, checks workspace members recursively (--recursive flag)
    required: false
    default: 'false'

runs:
  using: composite
  steps:
    - name: Configure git
      shell: bash
      run: | # shell
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"

    - name: Verify deno.json exists
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: | # shell
        if [[ ! -f "deno.json" ]] && [[ ! -f "deno.jsonc" ]]; then
          echo "âŒ Error: No deno.json or deno.jsonc file found in the current directory"
          echo "Current directory: $(pwd)"
          echo "Files in directory:"
          ls -la
          exit 1
        fi

    - name: Initialize step summary
      shell: bash
      run: | # shell
        echo "# Deno Dependency Updates" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

    - name: Run deno outdated
      id: outdated
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        RECURSIVE: ${{ inputs.recursive }}
      run: | # shell
        set -e
        echo "ðŸ” Checking for outdated Deno dependencies..."
        echo ""
        
        # Build deno command flags
        DENO_FLAGS=""
        if [[ "$RECURSIVE" == "true" ]]; then
          DENO_FLAGS="--recursive"
        fi
        
        # Run deno outdated and capture output
        if ! OUTDATED_OUTPUT=$(deno outdated $DENO_FLAGS 2>&1); then
          echo "âŒ Error running deno outdated:"
          echo "$OUTDATED_OUTPUT"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âŒ **Error:** Failed to run \`deno outdated\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "$OUTDATED_OUTPUT" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        # Check if output is empty (might indicate no deno.lock or other issue)
        if [[ -z "$OUTDATED_OUTPUT" ]]; then
          echo "âš ï¸ Warning: deno outdated produced no output"
          echo "This usually means:"
          echo "  - No deno.lock file exists (run 'deno install' first)"
          echo "  - Or all dependencies are up to date"
          echo ""
          echo "Checking for deno.lock..."
          if [[ ! -f "deno.lock" ]]; then
            echo "âŒ Error: No deno.lock file found"
            echo "Please run 'deno install' in your repository first to generate deno.lock"
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "âŒ **Error:** No \`deno.lock\` file found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The Deno Update action requires a \`deno.lock\` file to track dependencies." >> $GITHUB_STEP_SUMMARY
            echo "Please run \`deno install\` in your repository and commit the generated \`deno.lock\` file." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          echo "âœ“ deno.lock exists, assuming all dependencies are up to date"
          echo "âœ“ All dependencies are up to date!" >> $GITHUB_STEP_SUMMARY
          exit 0
        fi
        
        echo "$OUTDATED_OUTPUT"
        echo ""
        
        # Save output for next step
        echo "$OUTDATED_OUTPUT" > /tmp/deno-outdated.txt

    - name: Get default branch
      id: default-branch
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      run: | # shell
        DEFAULT_BRANCH=$(git remote show origin | grep "HEAD branch" | cut -d: -f2 | xargs)
        echo "default-branch=$DEFAULT_BRANCH" >> $GITHUB_OUTPUT
        echo "Default branch: $DEFAULT_BRANCH"

    - name: Ensure PR labels exist
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        PR_LABELS: ${{ inputs.pr-labels }}
      run: | # shell
        if [[ -z "$PR_LABELS" ]]; then
          echo "No labels specified, skipping label creation"
          exit 0
        fi
        
        IFS=',' read -ra LABELS <<< "$PR_LABELS"
        for LABEL in "${LABELS[@]}"; do
          LABEL=$(echo "$LABEL" | xargs)
          if ! gh label list --json name --jq '.[].name' | grep -q "^${LABEL}$"; then
            echo "Creating label: $LABEL"
            if gh label create "$LABEL" --color "0366d6" --description "Automated label" 2>/dev/null; then
              echo "âœ“ Created label '$LABEL'"
            fi
          else
            echo "Label '$LABEL' already exists"
          fi
        done

    - name: Process outdated dependencies
      shell: bash
      working-directory: ${{ inputs.working-directory }}
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        VERSION_POLICY: ${{ inputs.version-policy }}
        PR_LABELS: ${{ inputs.pr-labels }}
        DRY_RUN: ${{ inputs.dry-run }}
        RECURSIVE: ${{ inputs.recursive }}
        DEFAULT_BRANCH: ${{ steps.default-branch.outputs.default-branch }}
      run: | # shell
        set -e
        
        # Create temp file for summary
        SUMMARY_FILE=$(mktemp)
        FAILED_UPDATES=0
        
        # Build deno command flags
        DENO_FLAGS=""
        if [[ "$RECURSIVE" == "true" ]]; then
          DENO_FLAGS="--recursive"
        fi
        
        # Determine update flag based on version policy
        UPDATE_FLAG="--latest"
        if [[ "$VERSION_POLICY" == "compatible" ]]; then
          UPDATE_FLAG="--compatible"
        fi
        
        # Build label arguments
        LABELS_ARG=""
        if [[ -n "$PR_LABELS" ]]; then
          IFS=',' read -ra LABELS <<< "$PR_LABELS"
          for LABEL in "${LABELS[@]}"; do
            LABEL=$(echo "$LABEL" | xargs)
            LABELS_ARG="$LABELS_ARG --label $LABEL"
          done
        fi
        
        # Parse the table output and process each outdated dependency
        cat /tmp/deno-outdated.txt | tail -n +4 | grep -v "^[â””â”œâ”Œ]" | while IFS= read -r line; do
          # Extract fields from table row: â”‚ Package â”‚ Current â”‚ Update â”‚ Latest â”‚
          if [[ $line =~ â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚[[:space:]]*([^â”‚]+)[[:space:]]*â”‚ ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            CURRENT="${BASH_REMATCH[2]}"
            UPDATE="${BASH_REMATCH[3]}"
            LATEST="${BASH_REMATCH[4]}"
            
            # Trim whitespace
            PACKAGE=$(echo "$PACKAGE" | xargs)
            CURRENT=$(echo "$CURRENT" | xargs)
            UPDATE=$(echo "$UPDATE" | xargs)
            LATEST=$(echo "$LATEST" | xargs)
            
            # Skip if empty
            [[ -z "$PACKAGE" ]] && continue
            
            # Determine which target version based on policy
            if [[ "$VERSION_POLICY" == "compatible" ]]; then
              TARGET="$UPDATE"
            else
              TARGET="$LATEST"
            fi
            
            # Skip if current matches target
            [[ "$CURRENT" == "$TARGET" ]] && continue
            
            # Determine update type
            CURRENT_PARTS=(${CURRENT//./ })
            TARGET_PARTS=(${TARGET//./ })
            
            UPDATE_TYPE="patch"
            if [[ ${TARGET_PARTS[0]} -gt ${CURRENT_PARTS[0]} ]]; then
              UPDATE_TYPE="major"
            elif [[ ${TARGET_PARTS[1]} -gt ${CURRENT_PARTS[1]} ]]; then
              UPDATE_TYPE="minor"
            fi
            
            echo "Processing: $PACKAGE ($CURRENT â†’ $TARGET) [$UPDATE_TYPE]"
            
            # Sanitize package name for branch
            SAFE_NAME=$(echo "$PACKAGE" | sed 's|^jsr:||; s|^npm:||; s|^https\?://||; s|[@/]|-|g; s|[^a-zA-Z0-9._-]||g')
            BRANCH_NAME="dependencies/deno/$SAFE_NAME"
            
            # Check if PR already exists
            EXISTING_PR=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")
            
            # Create or update branch
            git fetch origin "$DEFAULT_BRANCH"
            if git rev-parse --verify "origin/$BRANCH_NAME" >/dev/null 2>&1; then
              echo "  Updating existing branch: $BRANCH_NAME"
              git checkout -B "$BRANCH_NAME" "origin/$DEFAULT_BRANCH"
            else
              echo "  Creating new branch: $BRANCH_NAME"
              git checkout -b "$BRANCH_NAME" "origin/$DEFAULT_BRANCH"
            fi
            
            # Strip prefix from package name for deno update
            UPDATE_PACKAGE="${PACKAGE#*://}"
            [[ "$UPDATE_PACKAGE" == "$PACKAGE" ]] && UPDATE_PACKAGE="${PACKAGE#*:}"
            
            # Run deno update
            if ! deno update $DENO_FLAGS $UPDATE_FLAG "$UPDATE_PACKAGE"; then
              echo "  âš  Could not update $PACKAGE - skipping"
              FAILED_UPDATES=$((FAILED_UPDATES + 1))
              git checkout "$DEFAULT_BRANCH"
              continue
            fi
            
            # Check if anything changed
            if git diff --quiet; then
              echo "  No changes needed"
              git checkout "$DEFAULT_BRANCH"
              continue
            fi
            
            echo "  âœ“ Updated $PACKAGE"
            
            # Commit and push
            COMMIT_MSG="Bump $PACKAGE from $CURRENT to $TARGET"
            git add .
            git commit -m "$COMMIT_MSG"
            git push -f origin "$BRANCH_NAME"
            
            # Create or update PR
            PR_BODY="Bumps \`$PACKAGE\` from $CURRENT to $TARGET.
            
            **Update type:** $UPDATE_TYPE
            
            ---
            Created by [Deno Update Action](https://github.com/johngeorgewright/workflows)"
            
            if [[ -n "$EXISTING_PR" ]]; then
              echo "  âœ“ Updated PR #$EXISTING_PR"
              gh pr edit "$EXISTING_PR" --title "$COMMIT_MSG" --body "$PR_BODY"
              echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${TARGET}\` (_${UPDATE_TYPE}_) - Updated PR [#${EXISTING_PR}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/pull/${EXISTING_PR})" >> "$SUMMARY_FILE"
            else
              # Add --dry-run flag if in dry-run mode
              DRY_RUN_FLAG=""
              if [[ "$DRY_RUN" == "true" ]]; then
                DRY_RUN_FLAG="--dry-run"
              fi
              
              PR_URL=$(gh pr create \
                --title "$COMMIT_MSG" \
                --body "$PR_BODY" \
                --base "$DEFAULT_BRANCH" \
                --head "$BRANCH_NAME" \
                $LABELS_ARG \
                $DRY_RUN_FLAG)
              PR_NUMBER=$(echo "$PR_URL" | sed -n 's|.*/pull/\([0-9]*\)|\1|p')
              
              if [[ "$DRY_RUN" == "true" ]]; then
                echo "  âœ“ Would create PR (dry-run)"
                echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${TARGET}\` (_${UPDATE_TYPE}_) - Would create PR (dry-run)" >> "$SUMMARY_FILE"
              else
                echo "  âœ“ Created PR #$PR_NUMBER"
                echo "- **${PACKAGE}**: \`${CURRENT}\` â†’ \`${TARGET}\` (_${UPDATE_TYPE}_) - Created PR [#${PR_NUMBER}](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/pull/${PR_NUMBER})" >> "$SUMMARY_FILE"
              fi
            fi
            
            # Return to default branch
            git checkout "$DEFAULT_BRANCH"
            echo ""
          fi
        done
        
        # Save summary file path for next step
        echo "$SUMMARY_FILE" > /tmp/summary-file-path.txt
        echo "$FAILED_UPDATES" > /tmp/failed-updates-count.txt

    - name: Write summary
      if: always()
      shell: bash
      env:
        DRY_RUN: ${{ inputs.dry-run }}
      run: | # shell
        SUMMARY_FILE=$(cat /tmp/summary-file-path.txt 2>/dev/null || echo "")
        FAILED_UPDATES=$(cat /tmp/failed-updates-count.txt 2>/dev/null || echo "0")
        
        if [[ -n "$SUMMARY_FILE" ]] && [[ -s "$SUMMARY_FILE" ]]; then
          echo "## Updates" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat "$SUMMARY_FILE" >> $GITHUB_STEP_SUMMARY
          
          if [[ "$DRY_RUN" == "true" ]]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "_Running in dry-run mode - no PRs were created_" >> $GITHUB_STEP_SUMMARY
          fi
          
          rm -f "$SUMMARY_FILE"
        else
          echo "âœ“ All dependencies are up to date!" >> $GITHUB_STEP_SUMMARY
        fi
        
        # Clean up temp files
        rm -f /tmp/summary-file-path.txt
        rm -f /tmp/failed-updates-count.txt
        rm -f /tmp/deno-outdated.txt
        
        if [[ "$FAILED_UPDATES" -gt 0 ]]; then
          echo ""
          echo "âŒ Failed to update $FAILED_UPDATES package(s)"
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âš ï¸ **Warning:** $FAILED_UPDATES package(s) could not be updated. Check the logs above for details." >> $GITHUB_STEP_SUMMARY
          exit 1
        fi
        
        echo "âœ“ Done!"